---
title: Go 数组和切片
date: 2019-10-29 09:44:15
categories:
- Go
tags:
- Go
---
### 数组
数组的定义
```go
var a [3]int                    // 定义长度为3的int型数组, 元素全部为0
var b = [...]int{1, 2, 3}       // 定义长度为3的int型数组, 元素为 1, 2, 3
var c = [...]int{2: 3, 1: 2}    // 定义长度为3的int型数组, 元素为 0, 2, 3
var d = [...]int{1, 2, 4: 5, 6} // 定义长度为6的int型数组, 元素为 1, 2, 0, 0, 5, 6
```
第一种方式是定义一个数组变量的最基本的方式，数组的长度明确指定，数组中的每个元素都以零值初始化。

第二种方式定义数组，可以在定义的时候顺序指定全部元素的初始化值，数组的长度根据初始化元素的数目自动计算。

第三种方式是以索引的方式来初始化数组的元素，因此元素的初始化值出现顺序比较随意。这种初始化方式和map[int]Type类型的初始化语法类似。数组的长度以出现的最大的索引为准，没有明确初始化的元素依然用0值初始化。

第四种方式是混合了第二种和第三种的初始化方式，前面两个元素采用顺序初始化，第三第四个元素零值初始化，第五个元素通过索引初始化，最后一个元素跟在前面的第五个元素之后采用顺序初始化。

同类型的数组是可以相互赋值的：`长度一样，并且每个元素的类型也一样的数组，才是同类型的数组。`
``` go
arr := [5]int{1,2,3,4,5}
var arr1 [5]int = arr // success
var arr2 [4]int = arr // error
```
#### **指针数组：**
创建了一个指针数组，索引1和3都创建了内存空间，其他索引是指针的零值 `nil `
```go
arr := [5]*int{1:new(int),3:new(int)}

// 修改指针变量的值
*arr[1] = 1
```
`注：` 以上因为只有索引 1 和 3 分配了内存，所以只有他们能赋值，如果给索引 0 赋值，会提示` 无效内存`或者`nil指针引用`
``` go
panic: runtime error: invalid memory address or nil pointer dereference
```
数组的指针与指针数组：`*[5]int`是数组的指针，`[5]*int`是指针数组
### 切片
切片底层是数组，对象非常小，是只有三个字段的数据结构：

1. 指向底层数组的指针
2. 切片的长度
3. 切片的容量

##### **切片的声明**
make 方式，需要指定切片的长度

```go
slice := make([]int,5) // 此时切片长度，容量均为5
slice := make([]int,5,10) // 此时切片长度为5，容量是10（对应的是切片底层数组）
```
因为切片的底层是数组，所以创建切片时，如果不指定字面值的话，默认值就是数组的元素的零值。这里我们所以指定了容量是10，但是我们职能访问5个元素，因为切片的长度是5，剩下的5个元素，需要切片扩充后才可以访问。`容量必须>=长度，我们是不能创建长度大于容量的切片的`

##### **使用字面量，初始化指定值创建切片**
与创建数组很像，不过不用设置`[]`的值，此时切片长度和容量是相等的
```go
slice := []int{1,2,3,4,5}
```

切片还有 `nil切片`和`空切片`，他们长度和容量都是0，但是指向底层数据的指针不一样，`nil切片`意味着指向底层数组的指针为`nil`，而`空切片`对应的指针是个地址。
`nil切片`表示不存在的切片，而`空切片`表示一个空集合
```go
// nil切片
var nilSlice []int
// 空切片
slice := []int{}
```
##### **基于现有数组或者切片创建**
使用`[i:j]`，表示从索引`i`开始，到索引`j`结束，截取原数组或者切片形成新切片，新切片包含`i`索引,但不包含`j`索引。如果省略`i`或`j`,则默认是0或原数组或切片的长度。`i`和`j`都不能越界
```go
slice := []int{1,2,3,4,5}
slice1 := slice[:] 
slice2 := slice[0:]
slice3 := slice[:5]
```

此方法创建的新切片大小和容量计算公式:
```go
对于底层数组容量是k的切片slice[i:j]来说
长度: j-i
容量: k-i
```

`append`函数可以为切片追加新元素
```
如果切片的底层数组，没有足够的容量时，就会新建一个底层数组，把原来数组的值复制到新底层数组里，再追加新值，这时候就不会影响原来的底层数组了。
所以一般我们在创建新切片的时候，最好要让新切片的长度和容量一样，这样我们在追加操作的时候就会生成新的底层数组，和原有数组分离，就不会因为共用底层数组而引起奇怪问题,因为共用数组的时候修改内容，会影响多个切片。
```
`append`函数会智能的增长底层数组的容量，目前的算法是：容量小于1000个时，总是成倍的增长，一旦容量超过1000个，增长因子设为1.25，也就是说每次会增加25%的容量。