---
title: Go 并发和并行
date: 2019-10-29 17:31:53
categories:
- Go
tags:
- Go
---
#### **并发与并行**
`并发`:两个或者多个事件在`同一时间间隔`发生，是`一台处理器`同时处理`多个任务`
`并行`:两个或者多个事件在`同一时刻`发生，是`多台处理器`同时处理`多个任务`

**并发**在`同一时刻只能有一条指令执行`，但是多个进程指令被`快速轮换执行`。在宏观上具有多个进程同时执行效果，但是微观上只是把`时间分成若干段`，快速`交替执行多个进程`，并不是同时执行

**并行**在同一时刻有`多条指令`在`多个处理器上同时执行`，无论微观还是宏观都是一起执行

当我们创建一个`goroutine`的后，会先存放在`全局运行队列`中，等待Go运行时的调度器进行调度，把他们分配给其中的一个`逻辑处理器`，并放到这个逻辑处理器对应的`本地运行队列`中，最终等着被`逻辑处理器`执行即可。

***这一套管理、调度、执行 goroutine 的方式成为 Go 的并发。***

***创建多个`逻辑处理器`，这样调度器就可以`同时分配全局运行队列`中的 goroutine 到不同的逻辑处理器上并行执行，这是 Go 的并行***

创建一个 `goroutine` 是通过 `go` 关键字实现的，在 `go` 关键字后跟一个函数或者方法即可
```go
func main() {
    //设置逻辑处理器个数为1
	runtime.GOMAXPROCS(1)
	var wg sync.WaitGroup
	wg.Add(2) // 设置计数器为 2
	go func() {
		defer wg.Done() // 计数器减 1
		for i := 1; i < 100; i++ {
			// 增加耗时，当前 goroutine 被扔进全局队列，从局部队列拿其他 goroutine 执行
			time.Sleep(time.Second * 1)
			fmt.Println("A:", i)
		}
	}()

	go func() {
		defer wg.Done()
		for i := 1; i < 100; i++ {
			// 增加耗时，当前 goroutine 被扔进全局队列，从局部队列拿其他 goroutine 执行
			time.Sleep(time.Second * 1)
			fmt.Println("B:", i)
		}
	}()

	wg.Wait() // 如果计数器大于0，就会阻塞
	//所以 main 函数会等待两个 goroutine 完成后，在结束
}
```
这里的`sync.WaitGroup`其实是一个计数的信号量，<u>*使用它的目的是要main函数等待两个goroutine执行完成后再结束*</u>，不然这两个goroutine还在运行的时候，程序就结束了，看不到想要的结果。

`runtime.NumCPU()` 可以获取本机逻辑CPU个数